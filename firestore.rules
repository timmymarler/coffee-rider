rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /* Helpers */
    function isAuthed() {
      return request.auth != null;
    }

    function hasRole(role) {
      return isAuthed() && request.auth.token.role == role;
    }

    function isProOrAdmin() {
      return request.auth != null &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['pro','admin'];
    }
    
    function isGroupMember(groupId) {
      return isAuthed() &&
        exists(/databases/$(database)/documents/groups/$(groupId)/members/$(request.auth.uid));
    }
    
    function isGroupOwner(groupId) {
      return isAuthed() &&
        get(/databases/$(database)/documents/groups/$(groupId)).data.ownerId == request.auth.uid;
    }

    /* VERSIONS */
    match /versions/{docId} {
      allow read: if true;
      allow write: if hasRole('admin');
    }

    /* USERS */
    match /users/{userId} {
      allow create: if isAuthed() && request.auth.uid == userId;
      allow read: if isAuthed();
      allow update: if isAuthed() && request.auth.uid == userId;
    }

    /* UPGRADES */
    match /upgradeRequests/{id} {
      allow create: if isAuthed();
      allow read, update, delete: if hasRole('admin');
    }

    /* PLACES */
    match /places/{placeId} {
      allow read: if true;
      allow create: if isAuthed() && request.resource.data.createdBy == request.auth.uid;
      allow update: if isAuthed() && (
        request.auth.uid == resource.data.createdBy || hasRole('admin')
      );
      allow delete: if false;
    }

    match /places/{placeId}/comments/{commentId} {
      allow read: if true;
      allow create: if isAuthed() && request.resource.data.createdBy == request.auth.uid;
      allow update, delete: if isAuthed() && (
        request.auth.uid == resource.data.createdBy || hasRole('admin')
      );
    }

    /* ROUTES */
    match /routes/{routeId} {
      // For list queries (like filtering by groupId), allow if user is group member
      // Note: Firestore requires simpler rules for queries with where clauses
      allow list: if
        isAuthed() && (
          // Allow querying own routes
          request.auth.uid == resource.data.createdBy ||
          // Allow querying public routes
          resource.data.visibility == 'public' ||
          // Allow querying group routes (membership checked at query time via client)
          resource.data.visibility == 'group'
        );
      
      // For single document reads, enforce strict permissions
      allow get: if
        resource.data.visibility == 'public' ||
        (isAuthed() && resource.data.createdBy == request.auth.uid) ||
        (resource.data.visibility == 'group' && isAuthed() && isGroupMember(resource.data.groupId));

      allow create: if isAuthed() && request.resource.data.createdBy == request.auth.uid;
      allow update: if isAuthed() && (
        resource.data.createdBy == request.auth.uid ||
        (resource.data.visibility == 'group' && isGroupMember(resource.data.groupId) && request.resource.data.participants != null) ||
        hasRole('admin')
      );
      allow delete: if false;
    }

    /* GROUPS */
    match /groups/{groupId} {
      allow create: if isProOrAdmin();
      allow read: if isAuthed();
      allow update, delete: if isGroupOwner(groupId);

      match /members/{memberId} {
        allow read: if isAuthed();
        allow create: if isGroupOwner(groupId) || (isAuthed() && request.auth.uid == memberId);
        allow update, delete: if isGroupOwner(groupId);
      }
    }

    /* GROUPS - COLLECTION GROUP QUERY SUPPORT */
    /* Allows useAllUserGroups collectionGroup(members) query where uid == request.auth.uid */
    match /{path=**}/members/{memberId} {
      allow read: if isAuthed() && (
        request.auth.uid == memberId ||
        resource.data.uid == request.auth.uid
      );
    }

    /* INVITES */
    match /groupInvites/{inviteId} {
      allow create: if isProOrAdmin();

      allow read: if isAuthed() &&
        (request.auth.uid == resource.data.inviteeUid || 
         request.auth.email == resource.data.inviteeEmail ||
         isProOrAdmin());

      allow update: if (
        isAuthed() &&
        request.auth.uid == resource.data.inviteeUid &&
        resource.data.status == 'pending' &&
        resource.data.expiresAt != null &&
        request.time < resource.data.expiresAt &&
        request.resource.data.status in ['accepted', 'declined']
      ) || (
        isProOrAdmin()
      );
      
      allow delete: if isProOrAdmin();
    }

    /* ACTIVE RIDES - REAL-TIME LOCATION SHARING */
    /* Users can only share location when actively riding a shared route */
    /* Locations are ONLY visible to other riders on the SAME ride in the SAME group */
    match /activeRides/{userId} {
      // Can only create/update your own active ride document
      allow create, update: if
        isAuthed() &&
        request.auth.uid == userId &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.rideId is string &&
        request.resource.data.groupId is string &&
        isGroupMember(request.resource.data.groupId);
      
      // Can only delete your own active ride
      allow delete: if isAuthed() && request.auth.uid == userId;
      
      // Can query active rides (client filters by rideId + groupId for same-ride locations)
      // Limit enforced to prevent abuse
      allow list: if isAuthed() && request.query.limit <= 50;
      
      // Can read individual active ride if you're in the same group
      allow get: if isAuthed() && isGroupMember(resource.data.groupId);
    }
    
  }
}
