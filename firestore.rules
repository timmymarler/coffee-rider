rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /* Helpers */
    function isAuthed() {
      return request.auth != null;
    }

    function isAdmin() {
      return isAuthed() && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    function hasRole(role) {
      return isAuthed() && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == role;
    }

    function isProOrAdmin() {
      return request.auth != null &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['pro','admin'];
    }

    function canCreateEvents() {
      return isAuthed() && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['admin', 'pro', 'place-owner'];
    }

    function canCreateRoutes() {
      return isAuthed() && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['admin', 'pro'];
    }

    function canShareRoutes() {
      return isAuthed() && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['admin', 'pro'];
    }
    
    function isGroupMember(groupId) {
      return isAuthed() &&
        exists(/databases/$(database)/documents/groups/$(groupId)/members/$(request.auth.uid));
    }
    
    function isGroupOwner(groupId) {
      return isAuthed() &&
        get(/databases/$(database)/documents/groups/$(groupId)).data.ownerId == request.auth.uid;
    }

    /* VERSIONS */
    match /versions/{docId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    /* USERS */
    match /users/{userId} {
      allow create: if isAuthed() && request.auth.uid == userId;
      allow read: if isAuthed();
      allow update: if isAuthed() && request.auth.uid == userId;
    }

    /* UPGRADES */
    match /upgradeRequests/{id} {
      allow create: if isAuthed();
      allow read, update, delete: if isAdmin();
    }

    /* PLACES */
    match /places/{placeId} {
      allow read: if true;
      allow create: if isAuthed() && request.resource.data.createdBy == request.auth.uid;
      // Allow update if user is authenticated and is the creator or admin
      // Linked users (place owners) can update amenities and suitability on their linked place
      // Pro users can update amenities, suitability, and ratings on any place
      // Only admin and creators can update other fields
      allow update: if isAuthed() && (
        isAdmin() ||
        (resource.data.createdBy == request.auth.uid) ||
        // Linked user: check if this user has linkedPlaceId matching this place
        (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.linkedPlaceId == placeId &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['amenities', 'suitability', 'updatedAt'])) ||
        (isProOrAdmin() && 
         // Pro can update amenities, suitability, and ratings only (plus updatedAt)
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['amenities', 'suitability', 'crRatings', 'updatedAt']))
      );
      allow delete: if false;
    }

    match /places/{placeId}/comments/{commentId} {
      allow read: if true;
      allow create: if isAuthed() && request.resource.data.createdBy == request.auth.uid;
      allow update, delete: if isAuthed() && (
        request.auth.uid == resource.data.createdBy || isAdmin()
      );
    }

    /* ROUTES */
    match /routes/{routeId} {
      // For list queries (like filtering by groupId), allow if user is group member
      // Note: Firestore requires simpler rules for queries with where clauses
      allow list: if
        isAuthed() && (
          // Allow querying own routes
          request.auth.uid == resource.data.createdBy ||
          // Allow querying public routes
          resource.data.visibility == 'public' ||
          // Allow querying group routes (membership checked at query time via client)
          resource.data.visibility == 'group'
        );
      
      // For single document reads, enforce strict permissions
      allow get: if
        resource.data.visibility == 'public' ||
        (isAuthed() && resource.data.createdBy == request.auth.uid) ||
        (resource.data.visibility == 'group' && isAuthed() && isGroupMember(resource.data.groupId));

      // Route creation is allowed for any signed-in user creating their own document
      allow create: if isAuthed() && request.resource.data.createdBy == request.auth.uid;

      // Updates are allowed with stricter gating:
      // - Owners can update general route fields
      // - Changing visibility to 'public' or 'group' requires Pro/Admin
      // - Group participants may update the participants array while a group ride is active
      allow update: if isAuthed() && (
        // Admins can update
        isAdmin() ||

        // Group participant updates (only participants field)
        (resource.data.visibility == 'group' &&
         isGroupMember(resource.data.groupId) &&
         request.resource.data.participants != null) ||

        // Owner updates
        (
          resource.data.createdBy == request.auth.uid && (
            // If changing visibility to public/group, require Pro/Admin
            (
              resource.data.visibility != request.resource.data.visibility &&
              request.resource.data.visibility in ['public', 'group'] &&
              isProOrAdmin() && (
                // When sharing to group, groupId must be provided and user must be a member
                (request.resource.data.visibility == 'group' ?
                  (request.resource.data.groupId is string && isGroupMember(request.resource.data.groupId))
                  : true)
              )
            ) ||

            // Otherwise, owner can update when visibility stays the same or changes back to private
            (
              (
                request.resource.data.visibility == resource.data.visibility ||
                request.resource.data.visibility == 'private'
              )
            )
          )
        )
      );
      allow delete: if false;
    }

    /* RIDES - SAVED COMPLETED RIDES */
    match /rides/{rideId} {
      // Allow reading own rides
      allow get: if isAuthed() && resource.data.ownerId == request.auth.uid;
      
      // Allow listing own rides
      allow list: if isAuthed() && resource.data.ownerId == request.auth.uid;
      
      // Allow creating own rides
      allow create: if isAuthed() && request.resource.data.ownerId == request.auth.uid;
      
      // Allow updating own rides
      allow update: if isAuthed() && resource.data.ownerId == request.auth.uid;
      
      // No deletion allowed
      allow delete: if false;
    }

    /* GROUPS */
    match /groups/{groupId} {
      allow create: if isProOrAdmin();
      allow read: if isAuthed();
      allow update, delete: if isGroupOwner(groupId);

      match /members/{memberId} {
        allow read: if isAuthed();
        allow create: if isGroupOwner(groupId) || (isAuthed() && request.auth.uid == memberId);
        allow update, delete: if isGroupOwner(groupId);
      }
    }

    /* GROUPS - COLLECTION GROUP QUERY SUPPORT */
    /* Allows useAllUserGroups collectionGroup(members) query where uid == request.auth.uid */
    match /{path=**}/members/{memberId} {
      allow read: if isAuthed() && (
        request.auth.uid == memberId ||
        resource.data.uid == request.auth.uid
      );
    }

    /* INVITES */
    match /groupInvites/{inviteId} {
      allow create: if isProOrAdmin();

      allow read: if isAuthed() &&
        (request.auth.uid == resource.data.inviteeUid || 
         request.auth.email == resource.data.inviteeEmail ||
         isProOrAdmin());

      allow update: if (
        isAuthed() &&
        request.auth.uid == resource.data.inviteeUid &&
        resource.data.status == 'pending' &&
        resource.data.expiresAt != null &&
        request.time < resource.data.expiresAt &&
        request.resource.data.status in ['accepted', 'declined']
      ) || (
        isProOrAdmin()
      );
      
      allow delete: if isProOrAdmin();
    }

    /* ACTIVE RIDES - REAL-TIME LOCATION SHARING */
    /* Users can only share location when actively riding a shared route */
    /* Locations are ONLY visible to other riders on the SAME ride in the SAME group */
    match /activeRides/{userId} {
      // Can only create/update your own active ride document
      allow create, update: if
        isAuthed() &&
        request.auth.uid == userId &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.rideId is string &&
        request.resource.data.groupId is string &&
        isGroupMember(request.resource.data.groupId);
      
      // Can only delete your own active ride
      allow delete: if isAuthed() && request.auth.uid == userId;
      
      // Can query active rides (client filters by rideId + groupId for same-ride locations)
      // Limit enforced to prevent abuse
      allow list: if isAuthed() && request.query.limit <= 50;
      
      // Can read individual active ride documents for group member visibility indicator
      // The document only exists when someone is actively sharing, so this is safe
      // Location data itself is filtered client-side to same ride/group only
      allow get: if isAuthed();
    }

    /* EVENTS - USER CALENDAR EVENTS */
    /* Permission: only users with canCreateEvents capability (admin/pro/place-owner) */
    match /events/{eventId} {
      allow create: if isAuthed() && 
        request.resource.data.userId == request.auth.uid &&
        canCreateEvents();
      
      allow read: if isAuthed() && (
        isAdmin() ||
        // Pro/place-owner can read their own events
        (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['pro','place-owner'] && resource.data.userId == request.auth.uid) ||
        // Group events: allow if user is attempting to access a group event
        (resource.data.visibility == 'group' &&
          resource.data.groupIds is list &&
          resource.data.groupIds.size() > 0
        ) ||
        // Public events: allow all authed users
        (resource.data.visibility == 'public')
      );
      
      allow update: if isAuthed() && (
        isAdmin() ||
        (resource.data.userId == request.auth.uid)
      );
      
      allow delete: if isAuthed() && (
        isAdmin() ||
        (resource.data.userId == request.auth.uid)
      );
      
      allow list: if isAuthed();
    }
    
  }
}
